
Individual report for the COMP1730/6730 project assignment S2 2022
-------------------------------------------------------------------

Question 1: Write your name and ANU ID

# My ANU ID: u7100771
# My NAME: Guangming Zeng

I declare that this submission is my own work
[ref: https://www.anu.edu.au/students/academic-skills/academic-integrity ]
-------------------------------------------------------------------

Question 2: Select a piece of code in your assignment solution that
you have written, and explain:    
    T = 1
    last_over = None
    last_not_over = None
    while(True):
        # obtain a “good” configuration at time T
        # Also for cache control. I don't want to repeat the calculation. 
        # If cache is enough, get from cache. If not, generate it and add to cache.
        if T <= T_cal_max:
            position_forward_T = position_forward_T_cal[:T, :][-1]
        else:
            position_forward_T_x2, position_current, velocity_current, acceleration_current = forward_simulation_speedup_extend(position_current, velocity_current, acceleration_current, T  - T_cal_max, 1, data)
            position_forward_T_cal = np.vstack((position_forward_T_cal, position_forward_T_x2))
            position_forward_T = position_forward_T_cal[:T, :][-1]
            T_cal_max = T

        # another “approximate” configuration
        position_forward_1 = forward_simulation(path_to_file, T, 1)[-1]

        # compute the error between the two configurations using the Euclidean distance
        error = 0
        for i in range(0, len(position_forward_T), 2):
            error += np.sqrt((position_forward_T[i] - position_forward_1[i])**2 + (position_forward_T[i+1] - position_forward_1[i+1])**2)

        # apply binary search algorithm to find the largest T such that the error is less than epsilon
        if error <= epsilon:
            last_not_over = T
            if last_over is None:
                T = T * 2
            elif last_over - last_not_over <= 1:
                return last_not_over
            else:
                T = int((T + last_over) / 2)
        else:
            last_over = T
            T = int((T + last_not_over) / 2)

(a) What does this piece of code do?
This piece of code is to use binary search algorithm to find the largest T such that the error is less than epsilon. 

(b) How does it work?
First, it will obtain a “good” configuration at time T by stimulating the planetary system at T
Then, it will obtain another “approximate” configuration.

(c) What other possible ways did you consider to implement this
functionality, and why did you choose the one you did?

-------------------------------------------------------------------
