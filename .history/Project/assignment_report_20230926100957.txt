
Individual report for the COMP1730/6730 project assignment S2 2022
-------------------------------------------------------------------

Question 1: Write your name and ANU ID

# My ANU ID: u7100771
# My NAME: Guangming Zeng

I declare that this submission is my own work
[ref: https://www.anu.edu.au/students/academic-skills/academic-integrity ]
-------------------------------------------------------------------

Question 2: Select a piece of code in your assignment solution that
you have written, and explain:    
    T = 1
    last_over = None
    last_not_over = None
    while(True):
        # obtain a “good” configuration at time T
        # Also for cache control. I don't want to repeat the calculation. 
        # If cache is enough, get from cache. If not, generate it and add to cache.
        if T <= T_cal_max:
            position_forward_T = position_forward_T_cal[:T, :][-1]
        else:
            position_forward_T_x2, position_current, velocity_current, acceleration_current = forward_simulation_speedup_extend(position_current, velocity_current, acceleration_current, T  - T_cal_max, 1, data)
            position_forward_T_cal = np.vstack((position_forward_T_cal, position_forward_T_x2))
            position_forward_T = position_forward_T_cal[:T, :][-1]
            T_cal_max = T

        # another “approximate” configuration
        position_forward_1 = forward_simulation(path_to_file, T, 1)[-1]

        # compute the error between the two configurations using the Euclidean distance
        error = 0
        for i in range(0, len(position_forward_T), 2):
            error += np.sqrt((position_forward_T[i] - position_forward_1[i])**2 + (position_forward_T[i+1] - position_forward_1[i+1])**2)

        # apply binary search algorithm to find the largest T such that the error is less than epsilon
        if error <= epsilon:
            last_not_over = T
            if last_over is None:
                T = T * 2
            elif last_over - last_not_over <= 1:
                return last_not_over
            else:
                T = int((T + last_over) / 2)
        else:
            last_over = T
            T = int((T + last_not_over) / 2)

(a) What does this piece of code do?
This piece of code is to use binary search algorithm to find the largest T such that the error is less than epsilon. 

(b) How does it work?
First, it will obtain a “good” configuration at time T by stimulating the planetary system at T points. 
T may be higher or lower than before. T which is higher cover all the calculation than the lower T. We could store cache from higher T to avoid repeat calculation in lower T.
We evaluate T by comparing the error between the two configurations using the Euclidean distance. If smaller than epsilon, T is acceptable. Otherwise, T is not acceptable.
Obvious, T could start at minimum value 1. And we don't know the maximum value.
So, introduce last_over to record the maximum bundary which is already over epsilon. (T, not acceptable)
And, every T which is not over epsilon could be the last_not_over which is the minimum bundary. (T, acceptable) 
The minimum bundary should be as large as possible. We could record this when enlarge T if this T is still acceptable.
We could enlarge T by double it and let it become not acceptable, trying to find a maximum bundary as soon as possible.
Once we find the minimum boundary and maximum boundary, we could use binary search algorithm to find the largest T that meet the requirement.

(c) What other possible ways did you consider to implement this
functionality, and why did you choose the one you did?

Given minimum boundary and maximum boundary, we search T from their average value. And then narrow the boundaries on both sides.
The time complexity is O(log(n)).
It is much faster than just adding 1 continuously in each loop starting from minimum boundary OR, continuously subtract 1 from the maximum boundary.
The time complexity is O(n).

插值查找、哈希表查找也能用于查找，但从平均时间复杂度的角度来说，二分查找仍属于最优算法（之一）。


-------------------------------------------------------------------
