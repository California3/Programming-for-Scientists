
Individual report for the COMP1730/6730 project assignment S2 2022
-------------------------------------------------------------------

Question 1: Write your name and ANU ID

# My ANU ID: u7100771
# My NAME: Guangming Zeng

I declare that this submission is my own work
[ref: https://www.anu.edu.au/students/academic-skills/academic-integrity ]
-------------------------------------------------------------------

Question 2: Select a piece of code in your assignment solution that
you have written, and explain:    
    T = 1
    last_over = None
    last_not_over = None
    while(True):
        # obtain a “good” configuration at time T
        # Also for cache control. I don't want to repeat the calculation. 
        # If cache is enough, get from cache. If not, generate it and add to cache.
        if T <= T_cal_max:
            position_forward_T = position_forward_T_cal[:T, :][-1]
        else:
            position_forward_T_x2, position_current, velocity_current, acceleration_current = forward_simulation_speedup_extend(position_current, velocity_current, acceleration_current, T  - T_cal_max, 1, data)
            position_forward_T_cal = np.vstack((position_forward_T_cal, position_forward_T_x2))
            position_forward_T = position_forward_T_cal[:T, :][-1]
            T_cal_max = T

        # another “approximate” configuration
        position_forward_1 = forward_simulation(path_to_file, T, 1)[-1]

        # compute the error between the two configurations using the Euclidean distance
        error = 0
        for i in range(0, len(position_forward_T), 2):
            error += np.sqrt((position_forward_T[i] - position_forward_1[i])**2 + (position_forward_T[i+1] - position_forward_1[i+1])**2)

        # apply binary search algorithm to find the largest T such that the error is less than epsilon
        if error <= epsilon:
            last_not_over = T
            if last_over is None:
                T = T * 2
            elif last_over - last_not_over <= 1:
                return last_not_over
            else:
                T = int((T + last_over) / 2)
        else:
            last_over = T
            T = int((T + last_not_over) / 2)

(a) What does this piece of code do?
This piece of code is to use binary search algorithm to find the largest T such that the error is less than epsilon. 

(b) How does it work?
First, it will obtain a “good” configuration at time T by stimulating the planetary system at T points. 
T may be higher or lower than before. T which is higer cover all the calculation than T which is lower. We could store cache to avoid repeat calculation. 
We evaluate the best T by comparing the error between the two configurations using the Euclidean distance.
Obvious, T could start at minimum value 1. And no maximum value so introduce last_over to record the maximum bundary which is already over epsilon. (not acceptable)
Every T which is not over epsilon could be the last_not_over which is the minimum bundary. (acceptable) 
last_not_over should be as large as possible. We could record it when enlarge T.
We enlarge T by double it, trying to find maximum bundary as soon as possible.
Once we find the minimum boundary and maximum boundary, we could use binary search algorithm to find the largest T that meet the requirement.

Then, it will obtain another “approximate” configuration.

(c) What other possible ways did you consider to implement this
functionality, and why did you choose the one you did?

-------------------------------------------------------------------
